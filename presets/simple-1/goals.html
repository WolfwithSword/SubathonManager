<!--
WIDGET_META
Width:400
Height:600
Url:https://github.com/WolfwithSword/SubathonManager/discussions/77#discussioncomment-15090982
showLastCompleted.Boolean:True
END_WIDGET_META
-->
<meta charset=utf-8>
<link href="https://fonts.cdnfonts.com/css/bright-orchid" rel="stylesheet">
<link href="https://fonts.cdnfonts.com/css/milker" rel="stylesheet">
<link href="https://fonts.cdnfonts.com/css/beachday" rel="stylesheet">

<link rel="stylesheet" type="text/css" href="./goals.styles.css"  />
<div class="container">
    <div class="goals-container" id="goalsContainer">
    </div>
</div>

<script>
    const goalsContainer = document.getElementById("goalsContainer");
    let goalsState = [];

    function filterToMostRecentCompleted(goals) {
        let lastCompletedIndex = goals.map(r => r.completed).lastIndexOf(true);
        let last = -1;
        if (showLastCompleted) {
            last = lastCompletedIndex === -1 ? 0 : lastCompletedIndex;
        } else {
            last = lastCompletedIndex + 1;
        }
        return last <= 0 ? goals : goals.slice(last);
    }
    
    function renderGoals(newGoals) {
        const existingRows = Array.from(goalsContainer.children);
        const existingMap = new Map(
            existingRows.map(row => [
                row.querySelector(".goal-text").textContent,
                row
            ])
        );

        const newKeys = newGoals.map(g => g.text);

        existingRows.forEach(row => {
            const text = row.querySelector(".goal-text").textContent;
            const points = row.querySelector(".goal-points").textContent;
            const existsInNew = newGoals.some(g => g.text == text && g.points.toString() == points);
            if (!existsInNew) {
                removeGoalRow(row);
            }
        });

        newGoals.forEach(goal => {
            let row = Array.from(goalsContainer.children).find(r => {
                const text = r.querySelector(".goal-text").textContent;
                const points = r.querySelector(".goal-points").textContent;
                return text == goal.text && points == goal.points.toString();
            });

            if (!row) {
                appendGoalRow(goal);
            } else {
                const item = row.querySelector(".goal-item");
                if (goal.completed) {
                    item.classList.add("completed");
                    row.classList.add("completed-row");
                 }
                else {
                    item.classList.remove("completed");
                    row.classList.remove("completed-row");
                }

                goalsContainer.appendChild(row);
            }
        });
    }
    
    function appendGoalRow(goal) {
        const row = createGoalElement(goal);
        row.classList.add("goal-row", "enter");
        goalsContainer.appendChild(row);

        requestAnimationFrame(() => {
            row.classList.remove("enter");
            row.classList.add("enter-active");
        });
    }
    
    function removeGoalRow(row) {
        row.classList.add("exit");

        row.style.height = row.offsetHeight + "px";
        row.offsetHeight;
        row.style.height = "0px";
        row.style.margin = "0px";

        setTimeout(() => {
            row.remove();
        }, 350);
    }
    
    function createGoalElement(goal) {
        const row = document.createElement("div");
        row.className = "goal-row";

        const item = document.createElement("div");
        item.className = "goal-item";
        if (goal.completed) {
            item.classList.add("completed");
            row.classList.add("completed-row");
        }

        const textSpan = document.createElement("span");
        textSpan.className = "goal-text";
        textSpan.textContent = goal.text;

        const pointsSpan = document.createElement("span");
        pointsSpan.className = "goal-points";
        pointsSpan.textContent = goal.points;

        item.appendChild(textSpan);
        item.appendChild(pointsSpan);
        row.appendChild(item);

        return row;
    }

    function handleGoalsUpdate(data) {
        if (data && data.type == "goals_list") {
            goalsState = [...data.goals].sort((a, b) => a.points - b.points);
            goalsState = filterToMostRecentCompleted(goalsState);
            renderGoals(goalsState);
        }
    }

    function handleGoalCompleted(data) {
        if (data && data.type == "goal_completed") {
            const completedText = data.goal_text;
            const completedAmt = data.goal_points;

            goalsState = goalsState.map(g =>
                (g.text == completedText && g.points == completedAmt) ? { ...g, completed: true } : g
            );
            goalsState = [...goalsState].sort((a, b) => a.points - b.points);
            goalsState = filterToMostRecentCompleted(goalsState);
            renderGoals(goalsState);
        }
    }
</script>